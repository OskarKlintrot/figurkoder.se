<!DOCTYPE html>
<html lang="sv">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Figurkoder.se</title>
    <link
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
      rel="stylesheet"
    />
    <style>
      :root {
        /* Colors */
        --color-primary: #007aff;
        --color-primary-hover: #0056cc;
        --color-secondary: #dc3545;
        --color-secondary-hover: #c82333;
        --color-text: #333;
        --color-text-muted: #666;
        --color-text-light: #6c757d;
        --color-text-lighter: #adb5bd;
        --color-background: #f5f5f5;
        --color-surface: #ffffff;
        --color-surface-hover: #f8f8f8;
        --color-surface-secondary: #f8f9fa;
        --color-surface-tertiary: #f0f0f0;
        --color-border: #ddd;
        --color-border-light: #e9ecef;
        --color-border-lighter: #dee2e6;
        --color-border-lightest: #eee;
        --color-nav-hover: #e8e8e8;
        --color-success: #28a745;
        --color-warning: #ffc107;
        --color-warning-bg: #fff3cd;
        --color-warning-text: #856404;
        --color-error: #dc3545;

        /* Spacing */
        --spacing-xs: 0.25rem;
        --spacing-sm: 0.5rem;
        --spacing-md: 0.625rem;
        --spacing-lg: 0.75rem;
        --spacing-xl: 1rem;
        --spacing-2xl: 1.25rem;
        --spacing-3xl: 1.5rem;
        --spacing-4xl: 2rem;
        --spacing-5xl: 2.5rem;

        /* Additional specific spacing values */
        --spacing-button: 0.875rem;
        --spacing-input: 0.9375rem;

        /* Border widths */
        --border-width-thin: 0.0625rem;
        --border-width-thick: 2px;

        /* Font sizes */
        --font-size-xs: 0.75rem;
        --font-size-sm: 0.875rem;
        --font-size-base: 1rem;
        --font-size-lg: 1.125rem;
        --font-size-xl: 1.25rem;
        --font-size-2xl: 1.5rem;
        --font-size-3xl: 3rem;

        /* Border radius */
        --radius-sm: 0.25rem;
        --radius-md: 0.375rem;
        --radius-lg: 0.5rem;
        --radius-xl: 0.75rem;
        --radius-2xl: 12px;
        --radius-full: 50%;

        /* Shadows */
        --shadow-sm: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.1);
        --shadow-md: 0 0.25rem 0.5rem rgba(0, 0, 0, 0.15);
        --shadow-lg: 0 4px 12px rgba(0, 0, 0, 0.15);
        --shadow-xl: 0 0.125rem 0.375rem rgba(0, 0, 0, 0.05);

        /* Transitions */
        --transition-fast: 0.1s;
        --transition-normal: 0.2s;
        --transition-slow: 0.3s;

        /* Layout */
        --max-width-page: 25rem;
        --max-width-game: 500px;
        --max-width-game-controls: 400px;
        --max-width-solution: 300px;
        --max-width-replay-btn: 200px;

        /* Z-index */
        --z-countdown: 10;
        --z-header: 100;
        --z-overlay: 999;
        --z-menu: 1000;
      }

      .tile-category {
        font-size: 0.75rem;
        color: var(--color-text-muted);
        text-transform: uppercase;
        letter-spacing: 0.05em;
        background: rgba(0, 0, 0, 0.05);
        padding: var(--spacing-lg) var(--spacing-2xl);
        margin: 0;
        border-top: var(--border-width-thin) solid rgba(0, 0, 0, 0.1);
      }

      /* Dark mode styles */
      @media (prefers-color-scheme: dark) {
        :root {
          /* Colors for dark mode */
          --color-primary: #0a84ff;
          --color-primary-hover: #409cff;
          --color-secondary: #ff453a;
          --color-secondary-hover: #ff6961;
          --color-text: #f2f2f7;
          --color-text-muted: #d1d1d6;
          --color-text-light: #c7c7cc;
          --color-text-lighter: #aeaeb2;
          --color-background: #000000;
          --color-surface: #1c1c1e;
          --color-surface-hover: #2c2c2e;
          --color-surface-secondary: #2c2c2e;
          --color-surface-tertiary: #3a3a3c;
          --color-border: #38383a;
          --color-border-light: #48484a;
          --color-border-lighter: #545456;
          --color-border-lightest: #636366;
          --color-nav-hover: #3a3a3c;
          --color-success: #30d158;
          --color-warning: #ff9f0a;
          --color-warning-bg: #1f1611;
          --color-warning-text: #ffcc02;
          --color-error: #ff453a;

          /* Shadows for dark mode - lighter for visibility */
          --shadow-sm: 0 0.125rem 0.25rem rgba(255, 255, 255, 0.05);
          --shadow-md: 0 0.25rem 0.5rem rgba(255, 255, 255, 0.1);
          --shadow-lg: 0 4px 12px rgba(255, 255, 255, 0.1);
          --shadow-xl: 0 0.125rem 0.375rem rgba(255, 255, 255, 0.02);
        }

        /* Dark mode specific overrides */
        .current-item-display {
          box-shadow: 0 2px 8px rgba(255, 255, 255, 0.1);
        }

        .control-input:focus {
          box-shadow: 0 0 0 3px rgba(10, 132, 255, 0.3);
        }

        .tile-category {
          background: linear-gradient(
            180deg,
            rgba(255, 255, 255, 0.1) 0%,
            rgba(255, 255, 255, 0.05) 100%
          );
          border-top: var(--border-width-thin) solid rgba(255, 255, 255, 0.2);
          color: var(--color-text-light);
        }

        .tile-title {
          text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
        }

        .nav-setting {
          background: linear-gradient(
            135deg,
            #1a1a1c 0%,
            #2c2c2e 100%
          ) !important;
          border: 1px solid #48484a !important;
        }

        .nav-item {
          background: var(--color-surface-tertiary);
          border: 1px solid var(--color-border);
          color: var(--color-text);
        }

        .nav-item:hover {
          background: var(--color-surface-secondary);
          border: 1px solid var(--color-border-light);
        }

        .nav-close {
          color: var(--color-text);
        }

        .nav-setting-label {
          color: var(--color-text) !important;
        }

        .nav-setting-label span {
          color: var(--color-text) !important;
        }
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Oxygen, Ubuntu, Cantarell, sans-serif;
        background: var(--color-background);
        color: var(--color-text);
      }

      .page {
        display: none;
        padding: 0 var(--spacing-2xl);
        max-width: var(--max-width-page);
        margin: 0 auto;
        margin-top: clamp(2rem, calc(1.5rem + 12vw), 6rem);
        width: 100%;
      }

      .page.active {
        display: block;
      }

      .header {
        display: flex;
        align-items: center;
        justify-content: center;
        padding: var(--spacing-2xl);
        position: fixed;
        top: 0;
        left: 50%;
        transform: translateX(-50%);
        background: var(--color-background);
        border-bottom: var(--border-width-thin) solid var(--color-border);
        z-index: var(--z-header);
        max-width: var(--max-width-page);
        width: 100%;
      }

      .back-btn {
        position: absolute;
        left: 0;
        background: none;
        border: none;
        font-size: 1.125rem;
        cursor: pointer;
        padding: var(--spacing-md);
        color: var(--color-text) !important;
        opacity: 1;
      }

      .menu-btn {
        position: absolute;
        right: 0;
        background: none;
        border: none;
        font-size: 1.125rem;
        cursor: pointer;
        padding: var(--spacing-md);
        color: var(--color-text) !important;
        opacity: 1;
      }

      h1 {
        font-size: var(--font-size-2xl);
        font-weight: 300;
      }

      .tiles-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: var(--spacing-2xl);
        margin-top: var(--spacing-5xl);
        margin-bottom: var(--spacing-5xl);
      }

      .tile {
        background: var(--color-surface);
        border: var(--border-width-thin) solid var(--color-border);
        border-radius: var(--radius-lg);
        padding: 0;
        text-align: center;
        cursor: pointer;
        transition: all var(--transition-normal);
        box-shadow: var(--shadow-sm);
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        align-items: stretch;
        overflow: hidden;
        min-height: 8rem;
      }

      .tile:hover {
        background: var(--color-surface-hover);
        transform: translateY(-0.125rem);
        box-shadow: var(--shadow-md);
      }

      .tile-title {
        font-size: 1rem;
        font-weight: 500;
        padding: var(--spacing-4xl) var(--spacing-2xl) var(--spacing-xl);
        flex-grow: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
      }

      .game-description {
        background: var(--color-surface);
        border-radius: var(--radius-lg);
        padding: var(--spacing-2xl);
        margin-bottom: var(--spacing-2xl);
        box-shadow: var(--shadow-sm);
      }

      .input-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: var(--spacing-md);
        margin-bottom: var(--spacing-2xl);
      }

      .input-row {
        grid-column: 1 / -1;
      }

      .game-input {
        width: 100%;
        padding: var(--spacing-input);
        border: var(--border-width-thin) solid var(--color-border);
        border-radius: var(--radius-md);
        font-size: 1rem;
        background: var(--color-surface);
        color: var(--color-text) !important;
      }

      .game-input:focus {
        outline: none;
        border-color: var(--color-primary);
      }

      /* Ensure autocomplete doesn't override text color */
      .game-input:-webkit-autofill,
      .game-input:-webkit-autofill:hover,
      .game-input:-webkit-autofill:focus {
        -webkit-text-fill-color: var(--color-text) !important;
        transition: background-color 5000s ease-in-out 0s;
      }

      .control-buttons {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        gap: var(--spacing-md);
        margin-bottom: var(--spacing-2xl);
      }

      .btn {
        padding: var(--spacing-lg) var(--spacing-2xl);
        border: var(--border-width-thin) solid var(--color-border);
        border-radius: var(--radius-md);
        background: var(--color-surface);
        cursor: pointer;
        font-size: var(--font-size-sm);
        transition: all var(--transition-normal);
      }

      .btn:hover {
        background: var(--color-surface-tertiary);
      }

      .btn:disabled {
        background: var(--color-surface-secondary);
        color: var(--color-text-light);
        border-color: var(--color-border-lighter);
        cursor: not-allowed;
        opacity: 0.6;
        transform: none;
      }

      .btn.primary {
        background: var(--color-primary);
        color: var(--color-surface);
        border-color: var(--color-primary);
      }

      .btn.primary:hover {
        background: var(--color-primary-hover);
      }

      .btn.primary:disabled {
        background: var(--color-text-light);
        border-color: var(--color-text-light);
        cursor: not-allowed;
        opacity: 0.6;
        transform: none;
      }

      .btn.secondary:disabled {
        background: var(--color-text-light);
        color: var(--color-text-lighter);
        border-color: var(--color-text-light);
        cursor: not-allowed;
        opacity: 0.6;
        transform: none;
      }

      .time-inputs {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: var(--spacing-md);
      }

      .result-container {
        background: var(--color-surface);
        border-radius: var(--radius-lg);
        padding: var(--spacing-2xl);
        margin-top: var(--spacing-2xl);
        box-shadow: var(--shadow-sm);
      }

      .results-table-container {
        margin-top: 1rem;
      }

      .results-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.75rem 0;
        border-bottom: 2px solid var(--color-border-light);
        font-weight: 600;
        color: var(--color-text-light);
        background: var(--color-surface-secondary);
        margin: 0 -1.25rem 0 -1.25rem;
        padding-left: 1.25rem;
        padding-right: 1.25rem;
      }

      .results-header-item {
        flex: 1;
        text-align: center;
      }

      .results-header-item:first-child {
        text-align: left;
      }

      .results-header-item:last-child {
        text-align: right;
      }

      .result-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: var(--spacing-input) 0;
        border-bottom: var(--border-width-thin) solid
          var(--color-border-lightest);
      }

      .result-item:last-child {
        border-bottom: none;
      }

      .results-summary {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 1rem 0 0.5rem 0;
        border-top: 2px solid var(--color-border-light);
        font-weight: 600;
        margin-top: 1rem;
      }

      .time-display {
        font-weight: 600;
        color: var(--color-primary);
      }

      .time-display.slow {
        background-color: var(--color-warning-bg);
        color: var(--color-warning-text);
        padding: var(--spacing-xs) var(--spacing-sm);
        border-radius: 4px;
      }

      .time-display.error {
        color: var(--color-error);
      }

      .replay-buttons {
        display: flex;
        gap: var(--spacing-xl);
        margin-top: var(--spacing-3xl);
        justify-content: center;
      }

      .replay-buttons .btn {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: var(--spacing-sm);
        padding: var(--spacing-button) var(--spacing-3xl);
        font-size: 1rem;
        font-weight: 600;
        max-width: var(--max-width-replay-btn);
      }

      @media (max-width: 480px) {
        .replay-buttons {
          flex-direction: column;
          gap: 0.75rem;
        }

        .replay-buttons .btn {
          max-width: none;
          padding: 0.75rem 1rem;
          font-size: 0.9rem;
        }
      }

      .nav-menu {
        position: fixed;
        top: 0;
        right: -18.75rem;
        width: 18.75rem;
        height: 100vh;
        background: var(--color-surface);
        box-shadow: -0.125rem 0 var(--spacing-md) rgba(0, 0, 0, 0.1);
        transition: right var(--transition-slow) ease;
        z-index: var(--z-menu);
        padding: 3.75rem var(--spacing-2xl) var(--spacing-2xl);
        overflow-y: auto;
      }

      .nav-menu.open {
        right: 0;
      }

      .nav-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.5);
        z-index: var(--z-overlay);
        opacity: 0;
        visibility: hidden;
        transition: all var(--transition-slow) ease;
      }

      .nav-overlay.open {
        opacity: 1;
        visibility: visible;
      }

      .nav-close {
        position: absolute;
        top: var(--spacing-2xl);
        right: var(--spacing-2xl);
        background: none;
        border: none;
        font-size: var(--font-size-2xl);
        cursor: pointer;
        padding: var(--spacing-md);
        color: var(--color-text);
      }

      .nav-item {
        display: block;
        width: 100%;
        padding: var(--spacing-input);
        margin-bottom: var(--spacing-md);
        background: var(--color-surface-hover);
        border: none;
        border-radius: var(--radius-lg);
        text-align: left;
        cursor: pointer;
        font-size: 1rem;
        color: var(--color-text);
        transition: background var(--transition-normal);
      }

      .nav-item:hover {
        background: var(--color-nav-hover);
      }

      .nav-setting {
        margin-top: var(--spacing-2xl);
        padding: var(--spacing-xl);
        background: linear-gradient(135deg, #f0f4ff 0%, #e8f2ff 100%);
        border-radius: var(--radius-xl);
        border: 1px solid #d1e7ff;
        box-shadow: var(--shadow-xl);
      }

      .nav-setting-label {
        display: flex;
        align-items: center;
        cursor: pointer;
        font-size: 1rem;
        font-weight: 500;
        color: var(--color-text);
        user-select: none;
        transition: color 0.2s ease;
      }

      .nav-setting-label:hover {
        color: var(--color-primary);
      }

      .nav-setting-label input[type="checkbox"] {
        margin-right: 0.75rem;
        width: 1.25rem;
        height: 1.25rem;
        accent-color: var(--color-primary);
        cursor: pointer;
        border-radius: 0.25rem;
        transition: all 0.2s ease;
      }

      .nav-setting-label input[type="checkbox"]:checked {
        transform: scale(1.1);
      }

      .nav-setting-label span {
        position: relative;
        transition: all 0.2s ease;
      }

      .nav-setting-label span::after {
        content: "📳";
        margin-left: 0.5rem;
        font-size: 1.1rem;
        opacity: 0.7;
        transition: all 0.2s ease;
      }

      .nav-setting-label:hover span::after {
        opacity: 1;
        transform: scale(1.1);
      }

      .nav-setting-label input[type="checkbox"]:checked + span::after {
        animation: vibrate-icon 0.5s ease-in-out;
      }

      @keyframes vibrate-icon {
        0%,
        100% {
          transform: translateX(0);
        }
        10%,
        30%,
        50%,
        70%,
        90% {
          transform: translateX(-1px);
        }
        20%,
        40%,
        60%,
        80% {
          transform: translateX(1px);
        }
      }

      .figurkod-list {
        background: var(--color-surface);
        border-radius: var(--radius-lg);
        padding: var(--spacing-2xl);
        margin-bottom: var(--spacing-2xl);
        box-shadow: var(--shadow-sm);
        max-height: 25rem;
        overflow-y: auto;
      }

      .figurkod-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: var(--spacing-lg) 0;
        border-bottom: var(--border-width-thin) solid
          var(--color-border-lightest);
      }

      .figurkod-item:last-child {
        border-bottom: none;
      }

      .figurkod-key {
        font-weight: 600;
        color: var(--color-primary);
        min-width: 3.75rem;
      }

      .figurkod-value {
        color: var(--color-text-muted);
        text-align: right;
      }

      .game-description a {
        color: var(--color-primary);
        text-decoration: none;
      }

      .game-description a:hover {
        text-decoration: underline;
      }

      .game-description h6 {
        color: var(--color-text-muted);
        font-style: italic;
        margin-bottom: var(--spacing-md);
      }

      .game-description p {
        margin-bottom: var(--spacing-xl);
      }

      .game-description p:last-child {
        margin-bottom: 0;
      }

      .figurkod-table {
        border-collapse: collapse;
        margin: var(--spacing-md) 0;
      }

      .figurkod-table td {
        padding: var(--spacing-xs);
      }

      @media (max-width: 30rem) {
        .page {
          padding: var(--spacing-md);
          max-width: none;
        }

        .header {
          max-width: none;
          padding: 1rem var(--spacing-md);
        }

        .tiles-grid {
          gap: 0.9375rem;
        }

        .tile {
          min-height: 7rem;
        }

        .tile-title {
          font-size: 0.95rem;
          padding: 1.75rem 1rem var(--spacing-button);
        }

        .tile-category {
          font-size: 0.7rem;
          padding: 0.675rem 1rem;
        }
      }

      /* Medium small phones */
      @media (max-width: 420px) {
        .page {
          padding: 0.5rem;
        }

        .header {
          padding: 0.9rem 0.5rem;
        }

        .tiles-grid {
          gap: 0.8rem;
        }

        .tile {
          min-height: 6.5rem;
        }

        .tile-title {
          font-size: 0.9rem;
          padding: var(--spacing-3xl) var(--spacing-button) 0.75rem;
        }

        .tile-category {
          font-size: 0.68rem;
          padding: 0.625rem var(--spacing-button);
        }
      }

      /* Extra small phones */
      @media (max-width: 320px) {
        .page {
          padding: 0.5rem;
        }

        .header {
          padding: var(--spacing-button) 0.5rem;
        }

        .tiles-grid {
          gap: 0.75rem;
          grid-template-columns: 1fr;
        }

        .tile {
          min-height: 5.5rem;
        }

        .tile-title {
          font-size: 0.85rem;
          padding: 1.25rem 0.75rem var(--spacing-md);
          line-height: 1.3;
        }

        .tile-category {
          font-size: 0.65rem;
          padding: 0.5rem 0.75rem;
          letter-spacing: 0.03em;
        }

        h1 {
          font-size: 1.25rem;
        }
      }

      /* Game Page Styles */
      .game-container {
        background: var(--color-surface);
        border-radius: var(--radius-lg);
        padding: var(--spacing-2xl);
        margin-bottom: var(--spacing-2xl);
        box-shadow: var(--shadow-sm);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: var(--spacing-2xl);
        max-width: var(--max-width-game);
        width: 100%;
        margin: 0 auto;
        margin-bottom: var(--spacing-2xl);
      }

      .current-item-container {
        width: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: var(--spacing-sm);
        position: relative;
        overflow: visible;
      }

      .current-item-display {
        background: var(--color-surface-secondary);
        border: 2px solid var(--color-border-light);
        border-radius: var(--radius-2xl);
        padding: var(--spacing-4xl) var(--spacing-3xl);
        font-size: 3rem;
        font-weight: 700;
        color: var(--color-text);
        text-align: center;
        min-width: 200px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        position: relative;
        word-break: break-all;
      }

      .countdown-timer {
        position: absolute;
        top: -1.8em;
        right: 1em;
        z-index: var(--z-countdown);
        display: none !important; /* Hide the countdown timer */
      }

      .countdown-circle {
        position: relative;
        width: 60px;
        height: 60px;
        background: var(--color-surface);
        border-radius: var(--radius-full);
        border: 3px solid var(--color-surface);
        box-shadow: var(--shadow-lg);
      }

      .countdown-svg {
        width: 100%;
        height: 100%;
        transform: rotate(-90deg);
      }

      .countdown-bg {
        fill: none;
        stroke: var(--color-border-light);
        stroke-width: 2;
      }

      .countdown-progress {
        fill: none;
        stroke: var(--color-primary);
        stroke-width: 2;
        stroke-linecap: round;
        stroke-dasharray: 100, 100;
        stroke-dashoffset: 0;
        transition: stroke-dashoffset var(--transition-fast) linear;
      }

      .countdown-text {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 1.25rem;
        font-weight: 700;
        color: var(--color-primary);
      }

      /* NÄSTA button countdown styles */
      .btn.primary.countdown-active {
        position: relative;
        overflow: hidden;
        background: var(--color-text-light); /* Use disabled button color as depleted state */
      }

      .btn.primary.countdown-active::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        height: 100%;
        width: 100%; /* Start at 100% and decrease to show countdown */
        background: var(--color-primary); /* Full color */
        transition: width 0.1s linear;
        z-index: 0;
      }

      .btn.primary.countdown-active .material-icons,
      .btn.primary.countdown-active > span:not(.material-icons) {
        position: relative;
        z-index: 1;
      }

      .solution-container {
        width: 100%;
        max-width: var(--max-width-solution);
      }

      .solution-display {
        width: 100%;
        padding: var(--spacing-button);
        font-size: 1.125rem;
        border: 1px solid var(--color-border-light);
        border-radius: 8px;
        text-align: center;
        background: var(--color-surface);
        color: var(--color-text-muted);
        min-height: 2.75rem;
        display: flex;
        align-items: center;
        justify-content: center;
        box-sizing: border-box;
        font-weight: 500;
      }

      .action-buttons {
        display: flex;
        gap: var(--spacing-lg);
        width: 100%;
        max-width: var(--max-width-solution);
      }

      .action-buttons .btn {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: var(--spacing-sm);
        padding: var(--spacing-button) var(--spacing-3xl);
        font-size: 1rem;
        font-weight: 600;
      }

      .btn.secondary {
        background: var(--color-secondary);
        color: var(--color-surface);
        border: none;
      }

      .btn.secondary:hover {
        background: var(--color-secondary-hover);
      }

      .btn.secondary:disabled:hover {
        background: var(--color-text-light);
        transform: none;
      }

      .game-controls {
        width: 100%;
        max-width: var(--max-width-game-controls);
        border-radius: var(--radius-2xl);
        padding: var(--spacing-3xl);
      }

      .control-row {
        display: flex;
        gap: var(--spacing-xl);
        margin-bottom: var(--spacing-2xl);
        align-items: end;
      }

      .control-row:last-child {
        margin-bottom: 0;
      }

      .control-group {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: var(--spacing-sm);
      }

      .control-group label {
        font-size: var(--font-size-sm);
        font-weight: 600;
        color: var(--color-text-muted);
        margin-bottom: var(--spacing-xs);
      }

      .control-input {
        width: 100%;
        padding: var(--spacing-button);
        border: 2px solid var(--color-border-light);
        border-radius: 8px;
        font-size: 1rem;
        text-align: center;
        background: var(--color-surface);
        color: var(--color-text) !important;
        transition: all var(--transition-normal) ease;
        font-weight: 500;
        box-sizing: border-box;
      }

      .control-input:focus {
        outline: none;
        border-color: var(--color-primary);
        box-shadow: 0 0 0 3px var(--color-primary-hover);
        background: var(--color-surface);
      }

      /* Ensure autocomplete doesn't override text color */
      .control-input:-webkit-autofill,
      .control-input:-webkit-autofill:hover,
      .control-input:-webkit-autofill:focus {
        -webkit-text-fill-color: var(--color-text) !important;
        transition: background-color 5000s ease-in-out 0s;
      }

      .control-input:disabled {
        background: var(--color-surface-secondary);
        color: var(--color-text-light);
        border-color: var(--color-border-lighter);
        cursor: not-allowed;
        opacity: 0.6;
      }

      /* Ensure select dropdowns look consistent */
      select.control-input {
        cursor: pointer;
        text-align: left;
      }

      select.control-input:disabled {
        cursor: not-allowed;
      }

      .checkbox-container {
        display: flex;
        align-items: center;
        justify-content: center;
        margin-top: 0.5rem;
      }

      .checkbox-label {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        cursor: pointer;
        font-size: 0.9rem;
        font-weight: 500;
        color: var(--color-text-muted);
        padding: 0.5rem;
        border-radius: 6px;
        transition: background-color 0.2s ease;
      }

      .checkbox-label:hover {
        background-color: var(--color-surface-hover);
      }

      .checkbox-label.disabled {
        color: var(--color-text-light);
        cursor: not-allowed;
        opacity: 0.6;
        background-color: transparent;
      }

      .checkbox-label input[type="checkbox"]:disabled {
        cursor: not-allowed;
        opacity: 0.6;
      }

      .checkbox-label input[type="checkbox"] {
        margin: 0;
        transform: scale(1.3);
        accent-color: var(--color-primary);
      }

      .playback-controls {
        display: flex;
        gap: 0.5rem;
        align-items: center;
      }

      .icon-btn {
        width: 3rem;
        height: 3rem;
        border-radius: var(--radius-full);
        display: flex;
        align-items: center;
        justify-content: center;
        border: none;
        background: var(--color-primary);
        color: var(--color-surface);
        cursor: pointer;
        transition: all var(--transition-normal) ease;
      }

      .icon-btn:hover {
        background: var(--color-primary-hover);
        transform: scale(1.05);
      }

      .icon-btn:disabled {
        background: var(--color-text-light);
        cursor: not-allowed;
        opacity: 0.8;
        transform: none;
      }

      .icon-btn:disabled .material-icons {
        color: var(--color-surface);
        opacity: 1;
      }

      .icon-btn .material-icons {
        font-size: var(--font-size-2xl);
      }

      @media (max-width: 480px) {
        .game-container {
          gap: 1rem;
          padding: 0.75rem;
          max-width: none;
          margin: 0 auto;
        }

        .current-item-display {
          padding: var(--spacing-3xl) 1rem;
          font-size: 2.25rem;
          min-width: 120px;
        }

        .countdown-timer {
          top: -1.5em;
          right: 0.5em;
        }

        .countdown-circle {
          width: 50px;
          height: 50px;
        }

        .countdown-text {
          font-size: 1rem;
        }

        .action-buttons .btn {
          padding: 0.75rem 1rem;
          font-size: 0.9rem;
        }

        .control-input {
          padding: 0.75rem;
          font-size: 0.9rem;
        }

        .checkbox-label {
          font-size: 0.85rem;
        }

        .game-controls {
          max-width: none;
          padding: 1.25rem;
        }
      }

      /* Extra small phones - game page */
      @media (max-width: 320px) {
        .game-container {
          gap: var(--spacing-button);
          padding: 0.5rem;
        }

        .current-item-display {
          padding: 1.25rem 0.75rem;
          font-size: 2rem;
          min-width: 100px;
        }

        .countdown-timer {
          top: -1.25em;
          right: 0.25em;
        }

        .countdown-circle {
          width: 45px;
          height: 45px;
        }

        .countdown-text {
          font-size: 0.9rem;
        }

        .solution-display {
          padding: var(--spacing-md);
          font-size: 1rem;
        }

        .action-buttons {
          flex-direction: column;
          gap: 0.5rem;
        }

        .action-buttons .btn {
          padding: 0.625rem var(--spacing-button);
          font-size: 0.85rem;
        }

        .control-input {
          padding: var(--spacing-md);
          font-size: 0.85rem;
        }

        .game-controls {
          max-width: none;
          padding: 1rem;
        }

        .control-group label {
          font-size: 0.8rem;
        }

        .checkbox-label {
          font-size: 0.8rem;
          gap: 0.5rem;
        }

        .icon-btn {
          width: 2.5rem;
          height: 2.5rem;
        }

        .icon-btn .material-icons {
          font-size: 1.25rem;
        }
      }

      /* Loading Spinner Styles */
      .spinner-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 50vh;
        gap: 1rem;
      }

      .spinner {
        width: 3rem;
        height: 3rem;
        border: 0.25rem solid #e9ecef;
        border-top: 0.25rem solid var(--color-primary);
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      .spinner-container p {
        font-size: 1rem;
        color: var(--color-text-light);
        margin: 0;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      /* Utility classes for dynamic styling */
      .hidden {
        display: none !important;
      }

      .visible {
        display: block !important;
      }

      /* Specific display types for visible elements */
      .btn.visible {
        display: inline-flex !important;
      }

      .countdown-timer.visible {
        visibility: visible;
      }

      .countdown-timer.hidden {
        visibility: hidden;
      }
    </style>
  </head>

  <body>
    <!-- Global Header -->
    <div class="header">
      <button class="back-btn hidden" id="back-btn" onclick="goBack()">
        ←
      </button>
      <h1 id="page-title">Figurkoder.se</h1>
      <button class="menu-btn" onclick="openMenu()">☰</button>
    </div>

    <!-- Navigation Menu -->
    <div class="nav-overlay" onclick="closeMenu()"></div>
    <div class="nav-menu" id="nav-menu">
      <button class="nav-close" onclick="closeMenu()">×</button>
      <button
        class="nav-item"
        onclick="navigateToPage('main-menu'); closeMenu();"
      >
        Hem
      </button>
      <button
        class="nav-item"
        onclick="navigateToPage('about-page'); closeMenu();"
      >
        Om sidan
      </button>
      <button
        class="nav-item"
        onclick="navigateToPage('faq-page'); closeMenu();"
      >
        Vanliga frågor
      </button>
      <button
        class="nav-item"
        onclick="navigateToPage('contact-page'); closeMenu();"
      >
        Kontakta mig
      </button>

      <!-- Vibration Setting -->
      <div class="nav-setting">
        <label class="nav-setting-label">
          <input
            type="checkbox"
            id="vibration-setting"
            checked
            onchange="toggleVibrationSetting()"
          />
          <span>Vibration</span>
        </label>
      </div>
    </div>

    <!-- Main Menu Page -->
    <div id="main-menu" class="page">
      <div class="tiles-grid" id="tiles-grid">
        <!-- Tiles will be generated dynamically -->
      </div>
    </div>

    <!-- Loading Spinner -->
    <div id="loading-spinner" class="page active">
      <div class="spinner-container">
        <div class="spinner"></div>
        <p>Laddar...</p>
      </div>
    </div>

    <!-- Game Page -->
    <div id="game-page" class="page">
      <div class="game-container">
        <!-- Current Item Display -->
        <div class="current-item-container">
          <div class="current-item-display" id="current-item">--</div>
          <!-- Countdown Timer -->
          <div class="countdown-timer" id="countdown-timer">
            <div class="countdown-circle">
              <svg class="countdown-svg" viewBox="0 0 36 36">
                <path
                  class="countdown-bg"
                  d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831"
                ></path>
                <path
                  class="countdown-progress"
                  id="countdown-progress"
                  d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831"
                ></path>
              </svg>
              <div class="countdown-text" id="countdown-text">6</div>
            </div>
          </div>
        </div>

        <!-- Solution Display -->
        <div class="solution-container">
          <div class="solution-display" id="solution-display">--</div>
        </div>

        <!-- Action Buttons -->
        <div class="action-buttons">
          <button class="btn secondary" id="show-btn" onclick="showAnswer()">
            <span class="material-icons">visibility</span>
            VISA
          </button>
          <button class="btn primary" id="next-btn" onclick="nextItem()">
            <span class="material-icons">arrow_forward</span>
            NÄSTA
          </button>
        </div>

        <!-- Game Controls -->
        <div class="game-controls">
          <div class="control-row">
            <div class="control-group">
              <label for="from-input">Från:</label>
              <input
                type="number"
                id="from-input"
                class="control-input"
                value="0"
                min="0"
              />
              <select id="from-dropdown" class="control-input hidden">
                <!-- Options will be populated dynamically -->
              </select>
            </div>
            <div class="control-group">
              <label for="to-input">Till:</label>
              <input
                type="number"
                id="to-input"
                class="control-input"
                value="99"
                min="0"
              />
              <select id="to-dropdown" class="control-input hidden">
                <!-- Options will be populated dynamically -->
              </select>
            </div>
          </div>

          <div class="control-row">
            <div class="control-group">
              <label for="time-input">Tid (sekunder):</label>
              <input
                type="number"
                id="time-input"
                class="control-input"
                value="6"
                min="1"
              />
            </div>
            <div class="control-group">
              <div class="checkbox-container">
                <label class="checkbox-label">
                  <input
                    type="checkbox"
                    id="learning-mode"
                    onchange="updateLearningMode()"
                  />
                  <span class="checkmark"></span>
                  Inlärning?
                </label>
              </div>
            </div>
          </div>
        </div>

        <!-- Playback Controls -->
        <div class="playback-controls">
          <button class="btn icon-btn" id="play-btn" onclick="startGame()">
            <span class="material-icons">play_arrow</span>
          </button>
          <button class="btn icon-btn" id="pause-btn" onclick="pauseGame()">
            <span class="material-icons">pause</span>
          </button>
          <button class="btn icon-btn" id="stop-btn" onclick="stopGame()">
            <span class="material-icons">stop</span>
          </button>
        </div>
      </div>
    </div>

    <!-- Results Page -->
    <div id="results-page" class="page">
      <div class="result-container">
        <h2 id="results-title">Resultat</h2>
        <div class="results-table-container">
          <div class="results-header">
            <span class="results-header-item">Figurkod</span>
            <span class="results-header-item">Tid</span>
          </div>
          <div id="results-list">
            <!-- Results will be populated dynamically -->
          </div>
          <div class="results-summary">
            <span>Genomsnittlig tid:</span>
            <span class="time-display" id="average-time">--</span>
          </div>
        </div>

        <!-- Replay Buttons -->
        <div class="replay-buttons">
          <button class="btn primary" onclick="replayAll()">
            <span class="material-icons">replay</span>
            Återställ
          </button>
          <button
            class="btn secondary"
            id="replay-slow-btn"
            onclick="replaySlow()"
          >
            <span class="material-icons">replay</span>
            <span id="replay-slow-text">Repetera långsamma</span>
          </button>
        </div>
      </div>
    </div>

    <!-- About Page -->
    <div id="about-page" class="page">
      <div class="game-description">
        <h2>Om sidan</h2>
        <h6>
          Figurkodsträning a lá
          <a href="http://themindacademy.se/" target="_blank"
            >themindacademy.se</a
          >
        </h6>
        <p>
          Appen är tänkt som ett komplement till
          <a href="http://mattiasribbing.se/" target="_blank"
            >Mattias Ribbings</a
          >
          kurs på
          <a href="http://www.themindacademy.se/" target="_blank"
            >themindacademy.se/</a
          >. Denna app är dock inofficiell och har inget samröre med dito sidor
          och kurser.
        </p>
        <p>Denna app är utvecklad helt ideellt.</p>
      </div>
    </div>

    <!-- FAQ Page -->
    <div id="faq-page" class="page">
      <div class="game-description">
        <h2>Vanliga frågor</h2>
        <h6>
          Figurkodsträning a lá
          <a href="http://themindacademy.se/" target="_blank"
            >themindacademy.se</a
          >
        </h6>
        <p>Figurkoderna baseras på följande alfanumeriska kod:</p>
        <table class="figurkod-table">
          <tr>
            <td>1</td>
            <td>–</td>
            <td>N</td>
          </tr>
          <tr>
            <td>2</td>
            <td>–</td>
            <td>THZ</td>
          </tr>
          <tr>
            <td>3</td>
            <td>–</td>
            <td>B</td>
          </tr>
          <tr>
            <td>4</td>
            <td>–</td>
            <td>WVK</td>
          </tr>
          <tr>
            <td>5</td>
            <td>–</td>
            <td>FR</td>
          </tr>
          <tr>
            <td>6</td>
            <td>–</td>
            <td>JPX</td>
          </tr>
          <tr>
            <td>7</td>
            <td>–</td>
            <td>SD</td>
          </tr>
          <tr>
            <td>8</td>
            <td>–</td>
            <td>GQL</td>
          </tr>
          <tr>
            <td>9</td>
            <td>–</td>
            <td>C</td>
          </tr>
        </table>
        <p>
          Den här sidan är skapad av
          <a href="https://www.linkedin.com/in/OskarKlintrot" target="_blank"
            >Oskar Klintrot</a
          >
          och är helt inofficiell.
        </p>
      </div>
    </div>

    <!-- Contact Page -->
    <div id="contact-page" class="page">
      <div class="game-description">
        <h2>Kontakta mig</h2>
        <h6>
          Figurkodsträning a lá
          <a href="http://themindacademy.se/" target="_blank"
            >themindacademy.se</a
          >
        </h6>
        <p>
          Om du har hittat en bugg på applikationen får du gärna rapportera en
          <a
            href="https://github.com/OskarKlintrot/figurkoder.se/issues"
            target="_blank"
            >"issue" på GitHub</a
          >. Om du är nyfiken på källkoden finns även den på
          <a
            href="https://github.com/OskarKlintrot/figurkoder.se"
            target="_blank"
            >GitHub</a
          >.
        </p>
        <p>
          Mig kontaktar ni enklast antingen på
          <a href="https://github.com/OskarKlintrot/" target="_blank">GitHub</a
          >,
          <a href="https://www.linkedin.com/in/OskarKlintrot" target="_blank"
            >LinkedIn</a
          >
          eller via min mail
          <a href="mailto:oskar.klintrot@gmail.com">oskar.klintrot@gmail.com</a
          >.
        </p>
      </div>
    </div>

    <!-- 404 Page -->
    <div id="404-page" class="page">
      <div class="game-description">
        <h2>404 - Sidan hittades inte</h2>
        <p>Tyvärr kunde vi inte hitta sidan du sökte efter.</p>
        <p>
          <a href="/" onclick="navigateToPage('main-menu'); return false;"
            >Gå tillbaka till startsidan</a
          >
        </p>
      </div>
    </div>

    <script type="module">
      import gameData from "/gameData.js";

      // Make gameData available globally for the existing code
      window.gameData = gameData;
    </script>
    <script>
      let currentGame = "";

      function openMenu() {
        document.getElementById("nav-menu").classList.add("open");
        document.querySelector(".nav-overlay").classList.add("open");
      }

      function closeMenu() {
        document.getElementById("nav-menu").classList.remove("open");
        document.querySelector(".nav-overlay").classList.remove("open");
      }

      function resetGameState() {
        // Stop any running game
        if (gameState.isGameRunning || gameState.paused) {
          // Clear all timers
          clearTimeout(gameState.gameTimer);
          clearInterval(gameState.countdownTimer);
          gameState.countdownTimer = null;
        }

        // Reset all game state variables to initial values
        gameState.currentGameData = [];
        gameState.originalGameData = [];
        gameState.masterGameData = [];
        gameState.currentItemIndex = 0;
        gameState.gameTimer = null;
        gameState.countdownTimer = null;
        gameState.gameStartTime = null;
        gameState.isGameRunning = false;
        gameState.showingSolution = false;
        gameState.countdownValue = 0;
        gameState.totalCountdownTime = 0;
        gameState.hasStarted = false;
        gameState.pausedCountdownValue = null;
        gameState.paused = false;
        gameState.gameResults = [];
        gameState.currentItemStartTime = null;
        gameState.pausedTime = 0;
        gameState.isReplayMode = false;
        gameState.usePresetData = false;
        // Note: vibrationEnabled is kept as it's a user setting

        // Reset UI elements to default state
        const timeInput = document.getElementById("time-input");
        if (timeInput) {
          const defaultTimeLimit = parseInt(timeInput.defaultValue);
          document.getElementById("countdown-text").textContent =
            defaultTimeLimit;
          document.getElementById("countdown-progress").style.strokeDashoffset =
            "0";
        }

        // Reset display elements
        document.getElementById("current-item").textContent = "---";
        document.getElementById("solution-display").textContent = "---";

        // Reset learning mode to default (unchecked)
        const learningModeCheckbox = document.getElementById("learning-mode");
        if (learningModeCheckbox) {
          learningModeCheckbox.checked = false;
        }
        gameState.isLearningMode = false;
      }

      function goBack() {
        const currentPageId = document.querySelector(".page.active").id;

        if (currentPageId === "game-page") {
          resetGameState(); // Reset game state before leaving game page
          navigateToPage("main-menu");
        } else if (currentPageId === "results-page") {
          navigateToPage("game-page");
        } else if (
          currentPageId === "about-page" ||
          currentPageId === "faq-page" ||
          currentPageId === "contact-page" ||
          currentPageId === "404-page"
        ) {
          navigateToPage("main-menu");
        }
      }

      function updateHeader(title, showBackButton = false) {
        document.getElementById("page-title").textContent = title;
        const backBtn = document.getElementById("back-btn");

        if (showBackButton) {
          backBtn.classList.remove("hidden");
          backBtn.classList.add("visible");
        } else {
          backBtn.classList.remove("visible");
          backBtn.classList.add("hidden");
        }
      }

      function navigateToPage(pageId, updateURL = true) {
        // Check if we're leaving the game page to reset state
        const currentPageId = document.querySelector(".page.active")?.id;
        if (
          currentPageId === "game-page" &&
          pageId !== "game-page" &&
          pageId !== "results-page"
        ) {
          resetGameState();
        }

        // Hide all pages
        document.querySelectorAll(".page").forEach((page) => {
          page.classList.remove("active");
        });

        // Show target page
        document.getElementById(pageId).classList.add("active");

        // Update URL if requested
        if (updateURL) {
          const url = getURLForPage(pageId);
          if (shouldUseHashRouting()) {
            window.location.hash = url.substring(1); // Remove the # prefix for setting hash
          } else {
            history.pushState(null, "", url);
          }
        }

        // Update header based on page
        switch (pageId) {
          case "main-menu":
            updateHeader("Figurkoder.se", false);
            break;
          case "game-page":
            updateHeader(
              currentGame && gameData && gameData[currentGame]
                ? gameData[currentGame].title
                : "Spel",
              true
            );
            break;
          case "results-page":
            updateHeader("Resultat", true);
            break;
          case "about-page":
            updateHeader("Om sidan", true);
            break;
          case "faq-page":
            updateHeader("Vanliga frågor", true);
            break;
          case "contact-page":
            updateHeader("Kontakta mig", true);
            break;
          case "404-page":
            updateHeader("404 - Sidan hittades inte", true);
            break;
        }
      }

      function shouldUseHashRouting() {
        return (
          window.location.hostname === "localhost" ||
          window.location.hostname === "127.0.0.1" ||
          window.location.hostname.endsWith(".local") ||
          window.location.protocol === "file:"
        );
      }

      function getURLForPage(pageId) {
        const prefix = shouldUseHashRouting() ? "#" : "";

        switch (pageId) {
          case "main-menu":
            return prefix + "/";
          case "game-page":
            return prefix + (currentGame ? `/game/${currentGame}` : "/game");
          case "results-page":
            return (
              prefix +
              (currentGame ? `/game/${currentGame}/results` : "/results")
            );
          case "about-page":
            return prefix + "/about";
          case "faq-page":
            return prefix + "/faq";
          case "contact-page":
            return prefix + "/contact";
          case "404-page":
            return prefix + "/404";
          default:
            return prefix + "/";
        }
      }

      function parseURL() {
        let path;

        if (shouldUseHashRouting()) {
          const hash = window.location.hash;
          path = hash.startsWith("#") ? hash.substring(1) : hash;
        } else {
          path = window.location.pathname;
        }

        // Clean up the path and remove empty segments
        const segments = path.split("/").filter((s) => s && s.length > 0);

        // If no segments or root path, default to main menu
        if (segments.length === 0 || path === "/" || path === "") {
          return { page: "main-menu", game: null };
        }

        if (segments[0] === "game") {
          if (segments.length === 1) {
            return { page: "game-page", game: null };
          }
          const gameType = segments[1];
          // Don't check gameData here since it might not be loaded yet
          // Let initializeFromURL handle the validation
          if (segments.length === 3 && segments[2] === "results") {
            return { page: "results-page", game: gameType };
          }
          return { page: "game-page", game: gameType };
        }

        switch (segments[0]) {
          case "about":
            return { page: "about-page", game: null };
          case "faq":
            return { page: "faq-page", game: null };
          case "contact":
            return { page: "contact-page", game: null };
          default:
            return { page: "404-page", game: null };
        }
      }

      function initializeFromURL() {
        const { page, game } = parseURL();

        // Hide loading spinner
        document.getElementById("loading-spinner").classList.remove("active");

        if (game) {
          // Check if gameData is available and if the game exists
          if (gameData && gameData[game]) {
            currentGame = game;
            const gameDataObj = gameData[game];

            // Safely set description if element exists
            const descElement = document.getElementById(
              "game-description-text"
            );
            if (descElement) {
              descElement.textContent = gameDataObj.description;
            }

            // Initialize the game if we're on the game page
            if (page === "game-page") {
              setTimeout(() => {
                initializeGame();
              }, 50);
            }

            navigateToPage(page, false);

            // Update header again now that currentGame and gameData are available
            if (page === "game-page") {
              updateHeader(gameDataObj.title, true);
            }
          } else if (gameData) {
            // gameData is loaded but game doesn't exist - show 404
            navigateToPage("404-page", false);
          } else {
            // gameData not loaded yet - wait a bit and try again
            setTimeout(() => {
              initializeFromURL();
            }, 100);
            return;
          }
        } else {
          navigateToPage(page, false);
        }
      }

      function navigateToGame(gameType) {
        // Reset any previous game state before starting a new game
        resetGameState();

        currentGame = gameType;
        const game = gameData[gameType];

        // Clear any replay flags when starting a new game
        gameState.usePresetData = false;
        gameState.isReplayMode = false;

        if (game) {
          // Safely set description if element exists
          const descElement = document.getElementById("game-description-text");
          if (descElement) {
            descElement.textContent = game.description;
          }
        }

        navigateToPage("game-page");
        setTimeout(() => {
          initializeGame(); // This will handle dropdown vs input logic
        }, 100);
      }

      // Game state object
      const gameState = {
        currentGameData: [],
        originalGameData: [], // Store the original filtered data used in the game
        masterGameData: [], // Store the very first filtered data from the initial game
        currentItemIndex: 0,
        gameTimer: null,
        countdownTimer: null,
        gameStartTime: null,
        isGameRunning: false,
        showingSolution: false,
        countdownValue: 0,
        totalCountdownTime: 0,
        hasStarted: false,
        pausedCountdownValue: null,
        paused: false,
        gameResults: [],
        currentItemStartTime: null,
        pausedTime: 0, // Track time spent in pause for current item
        isReplayMode: false, // Flag to prevent initializeGame during replay
        usePresetData: false, // Flag to indicate we're using preset replay data, skip range filtering
        vibrationEnabled: true, // Flag to control vibration
        isLearningMode: false, // Flag to control learning mode
      };

      function toggleVibrationSetting() {
        gameState.vibrationEnabled =
          document.getElementById("vibration-setting").checked;
        // Save setting to localStorage
        localStorage.setItem("vibrationEnabled", gameState.vibrationEnabled);
      }

      function updateLearningMode() {
        gameState.isLearningMode =
          document.getElementById("learning-mode").checked;
        // Update button states when learning mode changes
        updateButtonStates();
        // If game is not running, update the initial display
        if (!gameState.isGameRunning) {
          updateInitialDisplay();
        }
      }

      function initializeGame() {
        if (!currentGame || !gameData[currentGame]) {
          return;
        }

        // Skip initialization if we're in replay mode
        if (gameState.isReplayMode) {
          return;
        }

        // Clear preset data flag when initializing a new normal game
        gameState.usePresetData = false;

        const game = gameData[currentGame];
        gameState.currentGameData = [...game.data];
        gameState.currentItemIndex = 0;
        gameState.showingSolution = false;
        gameState.gameResults = [];
        gameState.currentItemStartTime = null;

        // Ensure range controls are visible for normal game initialization
        showRangeControls();

        // Handle dropdown vs input controls
        const useDropdown = game.dropdown || false;
        const fromInput = document.getElementById("from-input");
        const toInput = document.getElementById("to-input");
        const fromDropdown = document.getElementById("from-dropdown");
        const toDropdown = document.getElementById("to-dropdown");

        // Remove any existing event listeners by cloning and replacing elements
        const newFromInput = fromInput.cloneNode(true);
        const newToInput = toInput.cloneNode(true);
        fromInput.parentNode.replaceChild(newFromInput, fromInput);
        toInput.parentNode.replaceChild(newToInput, toInput);

        if (useDropdown) {
          // Show dropdowns, hide inputs
          newFromInput.classList.add("hidden");
          newToInput.classList.add("hidden");
          fromDropdown.classList.remove("hidden");
          toDropdown.classList.remove("hidden");

          // Populate dropdown options
          populateDropdowns(game.data);

          // Set default values to first and last items
          fromDropdown.value = "0";
          toDropdown.value = (gameState.currentGameData.length - 1).toString();
        } else {
          // Show inputs, hide dropdowns
          newFromInput.classList.remove("hidden");
          newToInput.classList.remove("hidden");
          fromDropdown.classList.add("hidden");
          toDropdown.classList.add("hidden");

          // Set default range for numeric data
          newFromInput.value = 0;
          // Set "Till" to "Från + 9", but not exceeding the data length
          const defaultToValue = Math.min(
            0 + 9,
            gameState.currentGameData.length - 1
          );
          newToInput.value = defaultToValue;

          // Add event listeners to ensure "Från" comes before "Till" for numeric inputs
          newFromInput.addEventListener("change", function () {
            const fromValue = parseInt(this.value) || 0;
            // Automatically set "Till" to "Från + 9", but not exceeding the data length
            const newToValue = Math.min(
              fromValue + 9,
              gameState.currentGameData.length - 1
            );
            newToInput.value = newToValue;

            // Update current-item display to show the new "from" item when game is not running
            if (
              !gameState.isGameRunning &&
              gameState.currentGameData.length > fromValue
            ) {
              const newCurrentItem = gameState.currentGameData[fromValue];
              document.getElementById("current-item").textContent =
                newCurrentItem[0];

              // Also update solution display based on learning mode
              const solutionDisplay =
                document.getElementById("solution-display");
              if (gameState.isLearningMode) {
                solutionDisplay.textContent = newCurrentItem[1];
              } else {
                solutionDisplay.textContent = "•••";
              }
            }
          });

          newToInput.addEventListener("change", function () {
            const fromValue = parseInt(newFromInput.value) || 0;
            const toValue =
              parseInt(this.value) || gameState.currentGameData.length - 1;

            // If "Till" is less than "Från", update "Från" to be equal to "Till"
            if (toValue < fromValue) {
              newFromInput.value = toValue;
            }
          });

          // Add event listener for time input to update countdown display
          const timeInput = document.getElementById("time-input");
          const newTimeInput = timeInput.cloneNode(true);
          timeInput.parentNode.replaceChild(newTimeInput, timeInput);

          newTimeInput.addEventListener("change", function () {
            // Update countdown display when time changes (only when game is not running)
            if (!gameState.isGameRunning) {
              const timeLimit =
                parseInt(this.value) || parseInt(this.defaultValue);
              document.getElementById("countdown-text").textContent = timeLimit;
            }
          });
        }

        // Only show initial display if not running
        if (!gameState.isGameRunning) updateInitialDisplay();
        updateButtonStates();
      }

      function updateInitialDisplay() {
        if (!gameState.currentGameData.length) {
          document.getElementById("current-item").textContent = "---";
          document.getElementById("solution-display").textContent = "---";
          document.getElementById("solution-display").classList.add("visible"); // Update countdown text to show current time setting
          const timeLimit =
            parseInt(document.getElementById("time-input").value) ||
            parseInt(document.getElementById("time-input").defaultValue);
          document.getElementById("countdown-text").textContent = timeLimit;

          // Always reset countdown progress circle
          document.getElementById("countdown-progress").style.strokeDashoffset =
            "0";
          return;
        }

        const currentItem = gameState.currentGameData[0];
        if (!currentItem || !currentItem[0]) {
          document.getElementById("current-item").textContent = "---";
          document.getElementById("solution-display").textContent = "---";
          return;
        }

        document.getElementById("current-item").textContent = currentItem[0];
        const solutionDisplay = document.getElementById("solution-display");
        solutionDisplay.classList.add("visible");
        if (gameState.isLearningMode) {
          solutionDisplay.textContent = currentItem[1];
        } else {
          solutionDisplay.textContent = "•••";
        }

        // Update countdown text to show current time setting
        const timeLimit =
          parseInt(document.getElementById("time-input").value) ||
          parseInt(document.getElementById("time-input").defaultValue);
        document.getElementById("countdown-text").textContent = timeLimit;

        // Always reset countdown progress circle
        document.getElementById("countdown-progress").style.strokeDashoffset =
          "0";
      }

      function updateButtonStates() {
        const playBtn = document.getElementById("play-btn");
        const pauseBtn = document.getElementById("pause-btn");
        const stopBtn = document.getElementById("stop-btn");
        const showBtn = document.getElementById("show-btn");
        const nextBtn = document.getElementById("next-btn");
        const fromInput = document.getElementById("from-input");
        const toInput = document.getElementById("to-input");
        const fromDropdown = document.getElementById("from-dropdown");
        const toDropdown = document.getElementById("to-dropdown");
        const timeInput = document.getElementById("time-input");
        const learningModeCheckbox = document.getElementById("learning-mode");
        const learningModeLabel =
          learningModeCheckbox.closest(".checkbox-label");

        // Determine if current game uses dropdowns
        const game = gameData[currentGame];
        const useDropdown = game && (game.dropdown || false);

        // Always show all control buttons
        playBtn.classList.add("visible");
        pauseBtn.classList.add("visible");
        stopBtn.classList.add("visible");

        if (gameState.isGameRunning) {
          // During game: disable play, enable pause/stop, disable inputs
          playBtn.disabled = true;
          pauseBtn.disabled = false;
          stopBtn.disabled = false;

          // Disable game configuration inputs during play
          fromInput.disabled = true;
          toInput.disabled = true;
          fromDropdown.disabled = true;
          toDropdown.disabled = true;
          timeInput.disabled = true;
          learningModeCheckbox.disabled = true;
          learningModeLabel.classList.add("disabled");

          // In learning mode, disable "Visa" button since answer is always shown
          // Also disable if answer is already shown for current item
          showBtn.disabled =
            gameState.isLearningMode || gameState.showingSolution;
          nextBtn.disabled = false;
        } else if (gameState.paused) {
          // During pause: enable play/stop, disable pause, disable inputs
          playBtn.disabled = false;
          pauseBtn.disabled = true;
          stopBtn.disabled = false;

          // Keep inputs disabled during pause
          fromInput.disabled = true;
          toInput.disabled = true;
          fromDropdown.disabled = true;
          toDropdown.disabled = true;
          timeInput.disabled = true;
          learningModeCheckbox.disabled = true;
          learningModeLabel.classList.add("disabled");

          // Action buttons disabled during pause
          showBtn.disabled = true;
          nextBtn.disabled = true;
        } else {
          // Game stopped: enable play, disable pause/stop, enable inputs
          playBtn.disabled = false;
          pauseBtn.disabled = true;
          stopBtn.disabled = true;

          // Enable game configuration inputs when stopped
          fromInput.disabled = false;
          toInput.disabled = false;
          fromDropdown.disabled = false;
          toDropdown.disabled = false;
          timeInput.disabled = false;
          learningModeCheckbox.disabled = false;
          learningModeLabel.classList.remove("disabled");

          // Action buttons disabled when stopped
          showBtn.disabled = true;
          nextBtn.disabled = true;
        }
      }

      function hideRangeControls() {
        // Hide both input and dropdown controls for range selection
        const fromInput = document.getElementById("from-input");
        const toInput = document.getElementById("to-input");
        const fromDropdown = document.getElementById("from-dropdown");
        const toDropdown = document.getElementById("to-dropdown");

        // Hide the control groups that contain the range inputs
        const controlGroups = document.querySelectorAll(".control-group");
        controlGroups.forEach((group) => {
          const label = group.querySelector("label");
          if (
            label &&
            (label.textContent.includes("Från:") ||
              label.textContent.includes("Till:"))
          ) {
            group.classList.add("hidden");
          }
        });
      }

      function showRangeControls() {
        // Show both input and dropdown controls for range selection
        const controlGroups = document.querySelectorAll(".control-group");
        controlGroups.forEach((group) => {
          const label = group.querySelector("label");
          if (
            label &&
            (label.textContent.includes("Från:") ||
              label.textContent.includes("Till:"))
          ) {
            group.classList.remove("hidden");
          }
        });
      }

      function startGame() {
        if (gameState.paused) {
          // Resume paused game
          gameState.isGameRunning = true;
          gameState.paused = false;

          // Adjust currentItemStartTime to account for paused time
          if (gameState.currentItemStartTime) {
            gameState.currentItemStartTime = Date.now() - gameState.pausedTime;
          }

          showCurrentItem(true); // Resume with existing countdown
          updateButtonStates();
          return;
        }

        // Clear replay mode flag to ensure normal initialization can proceed
        gameState.isReplayMode = false;

        // If we have no data or empty data, initialize the game first
        if (!gameState.currentGameData.length) {
          initializeGame();
          if (!gameState.currentGameData.length) {
            return;
          }
        }

        gameState.isGameRunning = true;
        gameState.hasStarted = true;
        gameState.paused = false;
        gameState.gameStartTime = Date.now();

        // Only filter data based on range if we're not using preset replay data
        if (!gameState.usePresetData) {
          // Filter data based on range
          const game = gameData[currentGame];
          const useDropdown = game.dropdown || false;

          let fromIndex, toIndex;
          if (useDropdown) {
            fromIndex =
              parseInt(document.getElementById("from-dropdown").value) || 0;
            toIndex =
              parseInt(document.getElementById("to-dropdown").value) ||
              gameState.currentGameData.length - 1;
          } else {
            fromIndex =
              parseInt(document.getElementById("from-input").value) || 0;
            toIndex =
              parseInt(document.getElementById("to-input").value) ||
              gameState.currentGameData.length - 1;
          }

          // Ensure indices are within bounds
          fromIndex = Math.max(0, fromIndex);
          toIndex = Math.min(gameState.currentGameData.length - 1, toIndex);

          const filteredData = gameState.currentGameData.slice(
            fromIndex,
            toIndex + 1
          );
          gameState.currentGameData = filteredData;

          // Only set originalGameData and masterGameData if they're not already set from a replay
          if (!gameState.originalGameData.length) {
            gameState.originalGameData = [...filteredData]; // Save the original filtered data
          }
          if (!gameState.masterGameData.length) {
            gameState.masterGameData = [...filteredData]; // Save the master copy that never changes
          }
        } else {
          // When using preset data, ensure originalGameData is set for future replays
          if (!gameState.originalGameData.length) {
            gameState.originalGameData = [...gameState.currentGameData];
          }
          // Don't clear the flag here - let it persist for multiple starts of the same replay session
        }

        // Initialize results tracking
        gameState.gameResults = [];
        gameState.currentItemStartTime = null;
        gameState.pausedTime = 0; // Reset paused time for new game
        // Shuffle data only if NOT in learning mode
        if (!gameState.isLearningMode) {
          for (let i = gameState.currentGameData.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [gameState.currentGameData[i], gameState.currentGameData[j]] = [
              gameState.currentGameData[j],
              gameState.currentGameData[i],
            ];
          }
        }
        gameState.currentItemIndex = 0;
        // Only call showCurrentItem to handle display logic
        showCurrentItem();
        updateButtonStates();

        // Countdown will start automatically in showCurrentItem() if not in learning mode
      }

      function pauseGame() {
        gameState.isGameRunning = false;
        gameState.paused = true;
        clearInterval(gameState.countdownTimer);
        gameState.countdownTimer = null; // Ensure timer is completely stopped
        gameState.pausedCountdownValue = gameState.countdownValue; // Save remaining time

        // Keep countdown styling on NÄSTA button during pause (but timer stops)
        // This maintains the visual state when resuming

        // Save the time spent on current item before pausing
        if (gameState.currentItemStartTime) {
          gameState.pausedTime += Date.now() - gameState.currentItemStartTime;
        }

        updateButtonStates();
      }

      function stopGame() {
        // Record current item result if game is running and we have a start time
        if (
          gameState.isGameRunning &&
          gameState.currentItemStartTime &&
          gameState.currentItemIndex < gameState.currentGameData.length
        ) {
          const currentItem =
            gameState.currentGameData[gameState.currentItemIndex];
          const totalTimeSpent =
            (Date.now() -
              gameState.currentItemStartTime +
              gameState.pausedTime) /
            1000;
          const timeSpent = Math.max(0.1, totalTimeSpent); // Minimum 0.1 seconds

          gameState.gameResults.push({
            figurkod: currentItem[0],
            answer: currentItem[1],
            timeSpent: timeSpent,
            showedAnswer: gameState.showingSolution, // True if answer was already shown
          });
        }

        // If game has started and we have results, show them (but not in learning mode)
        const shouldShowResults =
          gameState.hasStarted &&
          gameState.gameResults.length > 0 &&
          !gameState.isLearningMode;

        gameState.isGameRunning = false;
        gameState.hasStarted = false;
        gameState.paused = false;
        gameState.pausedCountdownValue = null;
        clearTimeout(gameState.gameTimer);
        clearInterval(gameState.countdownTimer);
        gameState.countdownTimer = null;
        gameState.countdownValue = 0;
        gameState.currentItemIndex = 0;
        gameState.showingSolution = false;
        gameState.currentItemStartTime = null;

        // Clean up NÄSTA button countdown
        const nextBtn = document.getElementById("next-btn");
        nextBtn.classList.remove("countdown-active");
        updateCountdownProgress(0);

        // Reset countdown display completely
        const timeLimit =
          parseInt(document.getElementById("time-input").value) ||
          parseInt(document.getElementById("time-input").defaultValue);
        document.getElementById("countdown-text").textContent = timeLimit;
        document.getElementById("countdown-progress").style.strokeDashoffset =
          "0";

        // Only show initial display if not running
        if (!gameState.isGameRunning) updateInitialDisplay();

        updateButtonStates();

        // Navigate to results if we should show them
        if (shouldShowResults) {
          updateResults();
          navigateToPage("results-page");
        }
      }

      function showCurrentItem(resume = false) {
        if (gameState.currentItemIndex >= gameState.currentGameData.length) {
          stopGame();
          return;
        }
        const currentItem =
          gameState.currentGameData[gameState.currentItemIndex];
        document.getElementById("current-item").textContent = currentItem[0];

        // Always start timing for this item when game is running, unless resuming
        if (gameState.isGameRunning && !resume) {
          gameState.currentItemStartTime = Date.now();
          gameState.pausedTime = 0; // Reset paused time for new item
        }

        const solutionDisplay = document.getElementById("solution-display");
        solutionDisplay.classList.add("visible");

        // Reset showingSolution for new item unless in learning mode
        if (!gameState.isLearningMode && !resume) {
          gameState.showingSolution = false;
        }

        if (gameState.isLearningMode || gameState.showingSolution) {
          solutionDisplay.textContent = currentItem[1];
        } else {
          solutionDisplay.textContent = "•••";
        }
        if (gameState.isLearningMode) {
          gameState.showingSolution = true;
          if (gameState.isGameRunning) {
            startCountdown(resume);
          }
        } else {
          if (gameState.isGameRunning) {
            startCountdown(resume);
          }
        }

        // Update button states based on current game state
        updateButtonStates();
      }

      function showAnswer() {
        if (gameState.currentItemIndex >= gameState.currentGameData.length)
          return;
        clearInterval(gameState.countdownTimer);
        
        // Clean up countdown styling from NÄSTA button
        const nextBtn = document.getElementById("next-btn");
        nextBtn.classList.remove("countdown-active");
        updateCountdownProgress(0);
        
        const currentItem =
          gameState.currentGameData[gameState.currentItemIndex];
        const solutionDisplay = document.getElementById("solution-display");
        solutionDisplay.textContent = currentItem[1];
        solutionDisplay.classList.add("visible");
        gameState.showingSolution = true;

        // Record that user needed to see the answer
        if (gameState.currentItemStartTime) {
          const timeSpent = Math.max(
            0.1,
            (Date.now() - gameState.currentItemStartTime) / 1000
          ); // Minimum 0.1 seconds
          gameState.gameResults.push({
            figurkod: currentItem[0],
            answer: currentItem[1],
            timeSpent: timeSpent,
            showedAnswer: true,
          });
          // Clear the start time to prevent duplicate recording
          gameState.currentItemStartTime = null;
        }

        // Update button states after showing answer
        updateButtonStates();
      }

      function startCountdown(resume = false) {
        const timeLimit =
          parseInt(document.getElementById("time-input").value) ||
          parseInt(document.getElementById("time-input").defaultValue);
        gameState.totalCountdownTime = timeLimit;
        // Only reset countdownValue if not resuming
        if (!resume) {
          gameState.countdownValue = timeLimit;
        } else if (gameState.pausedCountdownValue !== null) {
          gameState.countdownValue = gameState.pausedCountdownValue;
          gameState.pausedCountdownValue = null;
        }

        const isLearningMode = document.getElementById("learning-mode").checked;
        const nextBtn = document.getElementById("next-btn");

        // Hide countdown timer (but keep it for potential future use)
        document.getElementById("countdown-timer").classList.remove("visible");
        document.getElementById("countdown-text").textContent = Math.ceil(
          gameState.countdownValue
        );

        // Add countdown class to NÄSTA button and set initial progress
        nextBtn.classList.add("countdown-active");
        const currentProgress =
          (gameState.countdownValue / gameState.totalCountdownTime) * 100;
        
        // Update the ::before pseudo-element width through a style element
        updateCountdownProgress(currentProgress);

        // Set progress circle based on current countdown value (hidden, but kept for consistency)
        const progressCircle = document.getElementById("countdown-progress");
        progressCircle.style.strokeDashoffset = `${100 - currentProgress}`;

        gameState.countdownTimer = setInterval(() => {
          if (!gameState.isGameRunning || gameState.paused) return; // Prevent advancing if paused
          gameState.countdownValue -= 0.1;

          if (gameState.countdownValue <= 0) {
            clearInterval(gameState.countdownTimer);
            
            // Remove countdown class from NÄSTA button
            nextBtn.classList.remove("countdown-active");
            updateCountdownProgress(0);

            if (gameState.isGameRunning && !gameState.paused) {
              // Record timeout result before advancing with exact time limit
              if (
                gameState.currentItemStartTime &&
                gameState.currentItemIndex < gameState.currentGameData.length
              ) {
                const currentItem =
                  gameState.currentGameData[gameState.currentItemIndex];
                const timeSpent = gameState.totalCountdownTime; // Use exact time limit instead of actual elapsed time

                gameState.gameResults.push({
                  figurkod: currentItem[0],
                  answer: currentItem[1],
                  timeSpent: timeSpent,
                  showedAnswer: false, // User didn't get to see the answer
                });
                gameState.currentItemStartTime = null;
              }

              // Advance directly to next item without showing answer
              nextItem(gameState.isLearningMode); // Vibrate on auto-advance in learning mode
            }
            return;
          }

          // Update countdown display (still update hidden circle for consistency)
          const displayValue = Math.ceil(gameState.countdownValue);
          document.getElementById("countdown-text").textContent = displayValue;

          // Update progress on NÄSTA button (right to left countdown)
          const progress =
            (gameState.countdownValue / gameState.totalCountdownTime) * 100;
          updateCountdownProgress(progress);
          
          // Update progress circle (hidden)
          const progressCircle = document.getElementById("countdown-progress");
          progressCircle.style.strokeDashoffset = `${100 - progress}`;
        }, 100);
      }

      // Helper function to update countdown progress on the NÄSTA button
      function updateCountdownProgress(percentage) {
        const nextBtn = document.getElementById("next-btn");
        if (nextBtn.classList.contains("countdown-active")) {
          // Create or update a data attribute that we can style with CSS
          nextBtn.setAttribute('data-countdown-progress', percentage);
          
          // Directly update the pseudo-element through a dynamic style
          let styleElement = document.getElementById("countdown-style");
          if (!styleElement) {
            styleElement = document.createElement("style");
            styleElement.id = "countdown-style";
            document.head.appendChild(styleElement);
          }
          
          styleElement.textContent = `
            .btn.primary.countdown-active::before {
              width: ${percentage}% !important;
            }
          `;
        }
      }

      function nextItem(vibrate = false) {
        if (!gameState.isGameRunning || gameState.paused) return; // Prevent advancing if paused

        // Vibrate device for 100ms on auto-advance in learning mode (if enabled)
        if (
          gameState.vibrationEnabled &&
          navigator.vibrate &&
          gameState.isLearningMode &&
          vibrate
        ) {
          navigator.vibrate(100);
        }

        // Record result for current item if not already recorded (i.e., user pressed NEXT)
        if (
          gameState.currentItemStartTime &&
          gameState.currentItemIndex < gameState.currentGameData.length
        ) {
          const currentItem =
            gameState.currentGameData[gameState.currentItemIndex];
          const totalTimeSpent =
            (Date.now() -
              gameState.currentItemStartTime +
              gameState.pausedTime) /
            1000;
          const timeSpent = Math.max(0.1, totalTimeSpent); // Minimum 0.1 seconds

          gameState.gameResults.push({
            figurkod: currentItem[0],
            answer: currentItem[1],
            timeSpent: timeSpent,
            showedAnswer: gameState.showingSolution, // True if answer was shown before NEXT was pressed
          });
          gameState.currentItemStartTime = null;
        }

        // Stop the current countdown timer before advancing and clean up button countdown
        clearInterval(gameState.countdownTimer);
        gameState.countdownTimer = null;
        
        // Remove countdown styling from NÄSTA button
        const nextBtn = document.getElementById("next-btn");
        nextBtn.classList.remove("countdown-active");
        updateCountdownProgress(0);

        gameState.currentItemIndex++;

        if (gameState.currentItemIndex >= gameState.currentGameData.length) {
          if (gameState.isLearningMode) {
            // In learning mode, loop back to the beginning
            gameState.currentItemIndex = 0;
            showCurrentItem();
            return;
          } else {
            // In practice mode, navigate to results
            updateResults();
            navigateToPage("results-page");
            stopGame();
            return;
          }
        }

        showCurrentItem();

        // Auto-advance will continue automatically in showCurrentItem()
      }

      function updateResults() {
        const resultsList = document.getElementById("results-list");
        const averageTimeElement = document.getElementById("average-time");
        const resultsTitle = document.getElementById("results-title");

        // Update title to show game type
        if (currentGame && gameData[currentGame]) {
          resultsTitle.textContent = gameData[currentGame].title;
        }

        // Clear previous results
        resultsList.innerHTML = "";

        if (gameState.gameResults.length === 0) {
          resultsList.innerHTML =
            '<div class="result-item"><span>Inga resultat att visa</span><span>--</span></div>';
          averageTimeElement.textContent = "--";
          return;
        }

        // Calculate average time for items where answer wasn't shown
        const completedItems = gameState.gameResults.filter(
          (result) => !result.showedAnswer
        );
        const totalTime = completedItems.reduce(
          (sum, result) => sum + result.timeSpent,
          0
        );
        const averageTime =
          completedItems.length > 0 ? totalTime / completedItems.length : 0;

        // Display each result
        gameState.gameResults.forEach((result) => {
          const resultItem = document.createElement("div");
          resultItem.className = "result-item";

          const figurkodSpan = document.createElement("span");
          figurkodSpan.textContent = result.figurkod;

          const timeSpan = document.createElement("span");
          timeSpan.className = "time-display";

          if (result.showedAnswer) {
            timeSpan.textContent = result.answer;
            timeSpan.classList.add("error"); // Red color for shown answers
          } else {
            timeSpan.textContent = result.timeSpent.toFixed(1) + " sek";
            // Yellow background for times over 2 seconds
            if (result.timeSpent > 2) {
              timeSpan.classList.add("slow");
            }
          }

          resultItem.appendChild(figurkodSpan);
          resultItem.appendChild(timeSpan);
          resultsList.appendChild(resultItem);
        });

        // Update average time
        if (averageTime > 0) {
          averageTimeElement.textContent = averageTime.toFixed(1) + " sek";
        } else {
          averageTimeElement.textContent = "--";
        }

        // Update replay slow button
        const replaySlowBtn = document.getElementById("replay-slow-btn");
        const replaySlowText = document.getElementById("replay-slow-text");
        const slowOrErrorCount = gameState.gameResults.filter(
          (result) => result.timeSpent > 2 || result.showedAnswer
        ).length;

        replaySlowBtn.disabled = slowOrErrorCount === 0;
        replaySlowText.textContent = `Repetera långsamma (${slowOrErrorCount})`;
      }

      function replayAll() {
        // Set replay mode flag
        gameState.isReplayMode = true;

        // Restore original game data (the last used range) and restart with same settings
        if (gameState.originalGameData.length > 0) {
          gameState.currentGameData = [...gameState.originalGameData];
          gameState.usePresetData = true; // Flag that we're using preset data, skip range filtering
        } else {
          // If originalGameData is empty, we need to reset everything
          gameState.currentGameData = [];
          gameState.masterGameData = [];
        }

        navigateToPage("game-page");
        setTimeout(() => {
          // Show range controls for regular replay
          showRangeControls();

          // Clear replay mode flag and reset to stopped state
          gameState.isReplayMode = false;
          gameState.isGameRunning = false;
          gameState.hasStarted = false;
          gameState.paused = false;

          // Reset timer display completely
          clearInterval(gameState.countdownTimer);
          gameState.countdownTimer = null;
          gameState.pausedCountdownValue = null;
          gameState.countdownValue = 0;
          const timeLimit =
            parseInt(document.getElementById("time-input").value) ||
            parseInt(document.getElementById("time-input").defaultValue);
          document.getElementById("countdown-text").textContent = timeLimit;
          document.getElementById("countdown-progress").style.strokeDashoffset =
            "0";

          // Update initial display and button states
          updateInitialDisplay();
          updateButtonStates();
        }, 100);
      }

      function replaySlow() {
        if (!gameState.gameResults.length || !gameState.masterGameData.length)
          return;

        // Set replay mode flag
        gameState.isReplayMode = true;

        // Filter master game data to only include items that were slow or showed answer
        const slowItems = [];
        gameState.gameResults.forEach((result) => {
          if (result.timeSpent > 2 || result.showedAnswer) {
            // Find the corresponding item in masterGameData (the original filtered data)
            const foundItem = gameState.masterGameData.find(
              (item) => item[0] === result.figurkod
            );
            if (
              foundItem &&
              !slowItems.some((item) => item[0] === foundItem[0])
            ) {
              slowItems.push(foundItem);
            }
          }
        });

        if (slowItems.length === 0) return;

        // Override current game data with only slow items - but don't touch originalGameData or masterGameData
        gameState.currentGameData = [...slowItems];
        gameState.currentItemIndex = 0;
        gameState.gameResults = [];
        gameState.currentItemStartTime = null;

        // Go back to game page
        navigateToPage("game-page");
        setTimeout(() => {
          // Hide "Till" and "Från" fields for slow replay
          hideRangeControls();

          // Enable learning mode for slow replay
          document.getElementById("learning-mode").checked = true;
          gameState.isLearningMode = true;

          // Set the preset data flag AFTER navigation but BEFORE clearing replay mode
          gameState.usePresetData = true;

          // Clear replay mode flag and reset to stopped state
          gameState.isReplayMode = false;
          gameState.isGameRunning = false;
          gameState.hasStarted = false;
          gameState.paused = false;

          // Reset timer display completely
          clearInterval(gameState.countdownTimer);
          gameState.countdownTimer = null;
          gameState.pausedCountdownValue = null;
          gameState.countdownValue = 0;
          const timeLimit =
            parseInt(document.getElementById("time-input").value) ||
            parseInt(document.getElementById("time-input").defaultValue);
          document.getElementById("countdown-text").textContent = timeLimit;
          document.getElementById("countdown-progress").style.strokeDashoffset =
            "0";

          // Update initial display and button states - ensure we have data first
          if (gameState.currentGameData.length > 0) {
            updateInitialDisplay();
          } else {
            // Fallback if no data is available
            document.getElementById("current-item").textContent = "---";
            document.getElementById("solution-display").textContent = "---";
            const timeLimit =
              parseInt(document.getElementById("time-input").value) ||
              parseInt(document.getElementById("time-input").defaultValue);
            document.getElementById("countdown-text").textContent = timeLimit;
          }
          updateButtonStates();
        }, 100);
      }

      function startReplayGame() {
        // Start game without filtering data (use existing currentGameData)
        if (!gameState.currentGameData.length) return;

        gameState.isGameRunning = true;
        gameState.hasStarted = true;
        gameState.paused = false;
        gameState.gameStartTime = Date.now();

        // Initialize results tracking
        gameState.gameResults = [];
        gameState.currentItemStartTime = null;

        // DON'T overwrite masterGameData here - keep the original
        // masterGameData should remain unchanged from the first game

        // Shuffle data only if NOT in learning mode
        if (!gameState.isLearningMode) {
          for (let i = gameState.currentGameData.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [gameState.currentGameData[i], gameState.currentGameData[j]] = [
              gameState.currentGameData[j],
              gameState.currentGameData[i],
            ];
          }
        }
        gameState.currentItemIndex = 0;

        // Clear replay mode flag after starting
        gameState.isReplayMode = false;

        // Only call showCurrentItem to handle display logic
        showCurrentItem();
        updateButtonStates();
      }

      // Initialize game when navigating to game page
      function navigateToGame(gameId) {
        currentGame = gameId;
        navigateToPage("game-page");
        setTimeout(initializeGame, 100); // Small delay to ensure page is loaded
      }

      // Handle keyboard shortcuts
      document.addEventListener("keydown", function (e) {
        if (document.querySelector("#game-page.active")) {
          if (e.key === " " || e.key === "Enter") {
            // Space or Enter to show answer
            e.preventDefault();
            if (gameState.isGameRunning && !gameState.showingSolution) {
              showAnswer();
            }
          } else if (e.key === "ArrowRight" || e.key === "n" || e.key === "N") {
            // Right arrow or N to next
            e.preventDefault();
            if (gameState.isGameRunning) {
              nextItem();
            }
          }
        }
      });

      function updateTimer() {
        if (gameState.gameStartTime) {
          const elapsed = (Date.now() - gameState.gameStartTime) / 1000;
          // Could update a timer display here if needed
        }
      }

      function toggleMenu() {
        const menu = document.getElementById("nav-menu");
        const overlay = document.getElementById("nav-overlay");

        menu.classList.toggle("open");
        overlay.classList.toggle("open");
      }

      // Handle navigation changes (back/forward navigation)
      if (shouldUseHashRouting()) {
        window.addEventListener("hashchange", function () {
          initializeFromURL();
        });
      } else {
        window.addEventListener("popstate", function () {
          initializeFromURL();
        });
      }

      function getGameRange(gameId) {
        const game = gameData[gameId];
        const start = game.data[0][0];
        const stop = game.data[game.data.length - 1][0];
        return { start, stop };
      }

      function generateTiles() {
        const tilesGrid = document.getElementById("tiles-grid");

        Object.keys(gameData).forEach((gameId) => {
          const game = gameData[gameId];
          const range = getGameRange(gameId);
          const tile = document.createElement("div");
          tile.className = "tile";
          tile.onclick = () => navigateToGame(gameId);

          tile.innerHTML = `
            <div class="tile-title">${range.start} – ${range.stop}</div>
            <div class="tile-category">${game.title}</div>
          `;

          tilesGrid.appendChild(tile);
        });
      }

      // Initialize page based on URL when loaded
      window.addEventListener("DOMContentLoaded", function () {
        // Load vibration setting from localStorage
        const savedVibrationSetting = localStorage.getItem("vibrationEnabled");
        if (savedVibrationSetting !== null) {
          gameState.vibrationEnabled = savedVibrationSetting === "true";
          document.getElementById("vibration-setting").checked =
            gameState.vibrationEnabled;
        }

        // Initialize learning mode state from checkbox
        gameState.isLearningMode =
          document.getElementById("learning-mode").checked;

        generateTiles();
        // Add a small delay to ensure gameData is loaded
        setTimeout(() => {
          initializeFromURL();
          // Initialize button states on page load
          updateButtonStates();
        }, 100);
      });

      function populateDropdowns(data) {
        const fromDropdown = document.getElementById("from-dropdown");
        const toDropdown = document.getElementById("to-dropdown");

        // Clear existing options
        fromDropdown.innerHTML = "";
        toDropdown.innerHTML = "";

        // Remove existing event listeners by cloning and replacing elements
        const newFromDropdown = fromDropdown.cloneNode(false);
        const newToDropdown = toDropdown.cloneNode(false);
        newFromDropdown.id = fromDropdown.id;
        newFromDropdown.className = fromDropdown.className;
        newToDropdown.id = toDropdown.id;
        newToDropdown.className = toDropdown.className;

        fromDropdown.parentNode.replaceChild(newFromDropdown, fromDropdown);
        toDropdown.parentNode.replaceChild(newToDropdown, toDropdown);

        // Add options for each data item
        data.forEach((item, index) => {
          const optionFrom = document.createElement("option");
          optionFrom.value = index.toString();
          optionFrom.textContent = item[0]; // Use the key (first element) as display text
          newFromDropdown.appendChild(optionFrom);

          const optionTo = document.createElement("option");
          optionTo.value = index.toString();
          optionTo.textContent = item[0];
          newToDropdown.appendChild(optionTo);
        });

        // Add event listeners to ensure "Från" comes before "Till"
        newFromDropdown.addEventListener("change", function () {
          const fromIndex = parseInt(this.value);
          const toIndex = parseInt(newToDropdown.value);

          // If "Från" is greater than or equal to "Till", update "Till" to be after "Från"
          if (fromIndex >= toIndex) {
            newToDropdown.value = Math.min(
              fromIndex + 1,
              data.length - 1
            ).toString();
          }

          // Update current-item display to show the new "from" item when game is not running
          if (!gameState.isGameRunning && data.length > fromIndex) {
            const newCurrentItem = data[fromIndex];
            document.getElementById("current-item").textContent =
              newCurrentItem[0];

            // Also update solution display based on learning mode
            const solutionDisplay = document.getElementById("solution-display");
            if (gameState.isLearningMode) {
              solutionDisplay.textContent = newCurrentItem[1];
            } else {
              solutionDisplay.textContent = "•••";
            }
          }
        });

        newToDropdown.addEventListener("change", function () {
          const fromIndex = parseInt(newFromDropdown.value);
          const toIndex = parseInt(this.value);

          // If "Till" is less than or equal to "Från", update "Från" to be before "Till"
          if (toIndex <= fromIndex) {
            newFromDropdown.value = Math.max(toIndex - 1, 0).toString();
          }
        });

        // Set default values: first item for "Från", last item for "Till"
        newFromDropdown.value = "0";
        newToDropdown.value = (data.length - 1).toString();
      }
    </script>
  </body>
</html>
